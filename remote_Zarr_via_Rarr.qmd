---
title: "Accessing Zarr archives using `Rarr`"
format: html
execute: 
  cache: true
---

### Introduction

This notebook demonstrates how to **retrieve** remotely stored Zarr data using the `Rarr` package in R. We will explore how to **read** Zarr data (zarrays) and their metadata. For subsequent analysis and visualization we turn the zarray into `stars` objects which are more suitable for spatial data.

::: {.callout-note}
This notebook has a sibling, which demonstrates how to access the same Zarr data using the `Rarr` package. You can find it [here](./remote_Zarr_via_GDAL.html).
:::

### What we will learn

- âœï¸ How to edit URLs of Zarr archives to make them readable for GDAL
- ðŸ”Ž Which read-functions and arguments to use in `stars` and `terra`
- ðŸš§ Current limitations of these packages

### Prerequisites

We start at the point where **you already have found the URL** of your remote Zarr archive. This can be achived, e.g., using STAC, and is demonstrated in other notebooks in this series like ["Access the EOPF Zarr STAC API with R"](https://eopf-toolkit.github.io/eopf-101/51_eopf_stac_r.html). Here we use the example STAC asset from the [Sentinel-2 L1C MSI Zarr Product Exploration notebook](https://eopf-sample-service.github.io/eopf-sample-notebooks/sentinel-2-l1c-msi-zarr-product-exploration/#introduction) which is hosted on EODC's object storage.

```{r}
zarr_url = "https://objects.eodc.eu/e05ab01a9d56408d82ac32d69a5aae2a:sample-data/tutorial_data/cpm_v253/S2B_MSIL1C_20250113T103309_N0511_R108_T32TLQ_20250113T122458.zarr"
```

### Import packages

```{r}
#| message: false
#| warning: false

library(Rarr)      # reading
library(stars)     # spatial objects
library(dplyr)     # table operations
library(jsonlite)  # parsing metadata
library(mapview)   # interactive maps
```

## Metadata exploration with Rarr

::: {.callout-note}
In this notebook we show the current capabilities and limitations of `Rarr` in terms of reading Zarr array(s) and their metadata. Successful attempts are marked with a âœ…, failed attempts with a â›”.
:::

Using the `Rarr::zarr_overview` function we can get meta data for all assets in the remote Zarr archive as a table. Here list all arrays and their data type, compression, dimensions, etc.

```{r}
zarr_content = zarr_overview(zarr_url, as_data_frame = T) |> 
  mutate(var = sub(zarr_url, "", path)) |> 
  select(var, everything(), -path) 

filter(zarr_content, grepl("reflectance", var))
```

 We can see that all Sentinel-2 bands are in the archive, but split into directories based on spatial resolution (10, 20, 60 meters), which have different dimensions (number and size of pixels).

<a data-bs-toggle="collapse" data-bs-target="#collapseExample" aria-expanded="false" aria-controls="collapseExample">
  Click to show the full Zarr archive content
</a> <br>
<div class="collapse" id="collapseExample">
  <div class="card card-body">

```{r}
print(zarr_content)
```
  </div>
</div>


Now that we have an overview of the content, let's get some related metadata. `Rarr` provides the `read_zattrs` function for this purpose, which looks for the `.zattrs` file inside the archive. 

â›” Unfortunately we were not successful when applying it to our remote archive.
```{r}
#| error: true

read_zattrs(zarr_url)
read_zattrs(file.path(zarr_url, ".zattrs"))
```

âœ… As a simple workaround we can read the JSON directly:
```{r}
zattrs = read_json(file.path(zarr_url, ".zattrs"))
names(zattrs)
```

<a data-bs-toggle="collapse" data-bs-target="#collapseExample" aria-expanded="false" aria-controls="collapseExample">
  Click to show full Zarr archive metadata
</a> <br>
<div class="collapse" id="collapseExample">
  <div class="card card-body">

```{r}
print(zarr_content)
```
  </div>
</div>

The same information can be retrieved with `sf::gdal_utils('mdiminfo', ...)`.

## Reading Zarr data with `Rarr`

â›” `Rarr`, like `stars` and `terra`, is not capable of reading multiple arrays from the remote archive simultaneously.

```{r}
#| error: true

read_zarr_array(zarr_url)
```

âœ… But if a single band array is selected it works.

```{r}
band_variable = "/measurements/reflectance/r60m/b01"

zarray = read_zarr_array(paste0(zarr_url, band_variable))
str(zarray)
```

However, the function returen a matrix lacking any spatial metadata (e.g. CRS) or coordinates. Careful, the array has flipped dimensions! But we can access X and Y coordinates for each pixel seperately.
```{r}
zarray_60m_x = paste0(zarr_url, "/measurements/reflectance/r60m/x") |> 
  read_zarr_array()
zarray_60m_y = paste0(zarr_url, "/measurements/reflectance/r60m/y") |> 
  read_zarr_array()

print(range(zarray_60m_x))
print(range(zarray_60m_y))
```

Let's construct a stars object from the components found in the Zarr archive:
- data array
- X and Y coordinates
- CRS (from metadata)

```{r}
# read CRS from attributes
zarr_crs = zattrs$stac_discovery$properties$`proj:epsg`

# band name
var = basename(band_variable)

# read and transpose matrix before converting to stars
zz = st_as_stars(zarray |> t()) |> 
  st_set_dimensions(1, names = "X", values = zarray_60m_x) |> 
  st_set_dimensions(2, names = "Y", values = zarray_60m_y) |> 
  setNames(var)
st_crs(zz) = st_crs(zarr_crs)
zz
plot(zz, axes = TRUE)
```

all in one function:
```{r}
st_read_zarray = function(path, var, res, ...){
  
  # stopifnot valid zarr url / variable / resolution ...

  # get metadata including CRS
  zattrs = jsonlite::read_json(file.path(path, ".zattrs"))
  zarr_crs = zattrs$stac_discovery$properties$`proj:epsg`
  
  # zattrs$stac_discovery$properties$`eopf:resolutions`
  res_char = switch(as.character(res),
    "10" = "r10m",
    "20" = "r20m", 
    "60" = "r60m",
    stop("Resolution must be one of 10, 20, or 60.")
  )

  # ...: make use of index arguments of read_zarr_array??
  zarray = file.path(path, "measurements/reflectance", res_char, var) |> 
    read_zarr_array(...)
  zarray_x = file.path(path, "measurements/reflectance", res_char, "x") |> 
    read_zarr_array(...)
  zarray_y = file.path(path, "measurements/reflectance", res_char, "y") |> 
    read_zarr_array(...)
  
  # transpose matrixe before converting to stars
  z = zarray |> 
    t() |> 
    st_as_stars() |> 
    #st_set_crs(st_crs(zarr_crs)) |>   # does not seem to work in the pipeline.
    st_set_dimensions(1, names = "X", values = zarray_x) |> 
    st_set_dimensions(2, names = "Y", values = zarray_y) |> 
    setNames(var)
  st_crs(z) = st_crs(zarr_crs)
  return(z)
}
```


## Read and combine multiple zarrays

âœ… Now we can read multiple bands, combine to a single multi-band object, and visualize them.

```{r}
system.time({
  b01 = st_read_zarray(zarr_url, "b01", 60)
  b09 = st_read_zarray(zarr_url, "b09", 60)
  (multi_band = c(b01, b09) |> merge())
})

plot(multi_band, axes = TRUE)
```

Interactive visualization:

```{r}
#| echo: false
mapviewOptions(basemaps = c("OpenTopoMap","Esri.WorldImagery", 
                            "CartoDB.Positron"))
```

```{r}
#| message: false

mapview(multi_band)
```


## Benchmark

What is faster and/or more efficient - GDAL or Rarr?

```{r}
vsi_prefix = "ZARR:/vsicurl/"
vsi_url = paste0(vsi_prefix, dplyr::as_label(zarr_url)) 

f_stars = function(){rs = read_stars(paste(vsi_url, band_variable, sep = ":"))}
f_mdim = function(){sm = read_mdim(vsi_url, band_variable, proxy = FALSE) |> 
  setNames(basename(band_variable))}
f_rast = function(){tr = terra::rast(vsi_url, band_variable) |> terra::toMemory()}
f_rarr = function(){rr = st_read_zarray(zarr_url, "b01", 60)}
```

```{r}
#| warning: false

bench::mark(f_stars(), f_mdim(), f_rast(), f_rarr(), 
  check = F, iterations = 5)
```

The benchmark does not reveal a clear winner in terms of speed. However, `Rarr` seems to allocate more memory compared to `stars` and `terra`.

## ðŸ’ª Now it is your turn

- ðŸ”­ **Task**: Supply more arguments to `st_read_zarray` and pass a subset to read only parts on an array. 
- ðŸ’¾ **Task**: Try writing zarrays to disk using `Rarr::write_zarr_array()`
- Read the [Rarr documentation](https://huber-group-embl.github.io/Rarr/articles/Rarr.html).

## Conclusion

In this notebook we have demonstrated how to access remote Zarr archives in R using the `Rarr` package. We have seen that it is possible to read specific data arrays, but `read_zarr_array` lacks the ability of accessing anything other than the raw array. To combine it with a CRS or coordinates we need to leverage a spatial class like `stars` and manually set the relevant metadata.

## What's next?

Further tests should evaluate wether data retrieved via `Rarr` versus GDAL are identical in terms of spatial extent and offset.

Explore [this related notebook](./remote_Zarr_via_GDAL.html) which demonstrates how to access the same Zarr data using the GDAL Zarr driver via the `stars` and `terra` packages.


